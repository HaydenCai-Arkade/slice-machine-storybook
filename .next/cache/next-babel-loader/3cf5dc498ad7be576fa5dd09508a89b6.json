{"ast":null,"code":"import fs from 'fs';\nimport path from 'path';\nimport { SM_FILE } from 'sm-commons/consts';\nimport { getInfoFromPath as getLibraryInfo } from '../helper';\nimport { pascalize } from 'sm-commons/utils/str';\nconst ALL_KEY = '__allSlices';\n\nconst createDeclaration = libs => {\n  const imports = libs.reduce((acc, {\n    name,\n    pathToSlices\n  }) => `${acc}import * as ${name} from '${pathToSlices}'\\n`, '');\n  const spread = `const ${ALL_KEY} = { ${libs.reverse().reduce((acc, {\n    name\n  }) => `${acc} ...${name},`, '')} }`;\n  return `${imports}\\n${spread}\\n`;\n};\n\nconst createBody = () => `const NotFound = ({ sliceName }) => {\n\tconsole.log(\\`[sm - resolver] component \"\\${sliceName}\" not found.\\`)\n\treturn process.env.NODE_ENV !== 'production' ? <p>component \"{sliceName}\" not found.</p> : <div />\n}\n\nexport default ({ sliceName, i }) => {\n\treturn ${ALL_KEY}[sliceName] ? ${ALL_KEY}[sliceName] : () => <NotFound sliceName={sliceName} />\n}\n`;\n\nasync function handleLibraryPath(libPath) {\n  const {\n    isLocal,\n    pathExists,\n    pathToSlices\n  } = await getLibraryInfo(libPath);\n\n  if (!pathExists) {\n    console.warn(`[next-slicezone] path to library \"${pathToSlices}\" does not exist. Skipping.`);\n    return null;\n  }\n\n  const from = isLocal ? libPath.slice(2) : libPath;\n  const endPathToSlices = `${isLocal ? './' : ''}${from}${pathToSlices.split(from).slice(1).join('')}`;\n  return {\n    isLocal,\n    from,\n    name: pascalize(from),\n    pathToSlices: endPathToSlices\n  };\n}\n\nexport const createResolver = async () => {\n  const pathToSmFile = path.posix.join(process.cwd(), SM_FILE);\n  const {\n    libraries\n  } = fs.existsSync(pathToSmFile) ? JSON.parse(fs.readFileSync(pathToSmFile)) : {};\n\n  if (!libraries) {\n    return console.warn(`[next-slicezone] expects a non-empty \"libraries\" array in file \"${SM_FILE}\"`);\n  }\n\n  if (!Array.isArray(libraries) || !libraries.length) {\n    return console.error('[next-slicezone] expects \"libraries\" option to be a non-empty array');\n  }\n\n  const librariesInfo = await Promise.all(libraries.map(async lib => await handleLibraryPath(lib)));\n  const declaration = createDeclaration(librariesInfo.filter(e => e));\n  const body = createBody();\n  const file = `${declaration}\n${body}\n  `;\n  return fs.writeFileSync(path.join(process.cwd(), 'sm-resolver.js'), file);\n};","map":{"version":3,"sources":["/Users/caiheng/Desktop/slice-machine-storybook/node_modules/next-slicezone/features/components.js"],"names":["fs","path","SM_FILE","getInfoFromPath","getLibraryInfo","pascalize","ALL_KEY","createDeclaration","libs","imports","reduce","acc","name","pathToSlices","spread","reverse","createBody","handleLibraryPath","libPath","isLocal","pathExists","console","warn","from","slice","endPathToSlices","split","join","createResolver","pathToSmFile","posix","process","cwd","libraries","existsSync","JSON","parse","readFileSync","Array","isArray","length","error","librariesInfo","Promise","all","map","lib","declaration","filter","e","body","file","writeFileSync"],"mappings":"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","sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nimport { SM_FILE } from 'sm-commons/consts'\nimport { getInfoFromPath as getLibraryInfo } from '../helper'\nimport { pascalize } from 'sm-commons/utils/str'\n\n\nconst ALL_KEY = '__allSlices'\n\nconst createDeclaration = (libs) => {\n  const imports = libs.reduce((acc, { name, pathToSlicesÂ }) => `${acc}import * as ${name} from '${pathToSlices}'\\n`, '')\n  const spread = `const ${ALL_KEY} = { ${libs.reverse().reduce((acc, { name }) => `${acc} ...${name},`, '')} }`\n  return `${imports}\\n${spread}\\n`\n}\n\nconst createBody = () =>\n`const NotFound = ({ sliceName }) => {\n\tconsole.log(\\`[sm - resolver] component \"\\${sliceName}\" not found.\\`)\n\treturn process.env.NODE_ENV !== 'production' ? <p>component \"{sliceName}\" not found.</p> : <div />\n}\n\nexport default ({ sliceName, i }) => {\n\treturn ${ALL_KEY}[sliceName] ? ${ALL_KEY}[sliceName] : () => <NotFound sliceName={sliceName} />\n}\n`\n\nasync function handleLibraryPath(libPath) {\n  const {\n    isLocal,\n    pathExists,\n    pathToSlices,\n  } = await getLibraryInfo(libPath)\n\n  if (!pathExists) {\n    console.warn(`[next-slicezone] path to library \"${pathToSlices}\" does not exist. Skipping.`)\n    return null\n  }\n\n  const from = isLocal ? libPath.slice(2) : libPath\n\n  const endPathToSlices = `${isLocal ? './' : ''}${from}${pathToSlices.split(from).slice(1).join('')}`\n\n  return {\n    isLocal,\n    from,\n    name: pascalize(from),\n    pathToSlices: endPathToSlices\n  }\n}\n\nexport const createResolver = async () => {\n  const pathToSmFile = path.posix.join(process.cwd(), SM_FILE)\n  const { libraries } = fs.existsSync(pathToSmFile) ? JSON.parse(fs.readFileSync(pathToSmFile)) : {}\n\n  if (!libraries) {\n    return console.warn(`[next-slicezone] expects a non-empty \"libraries\" array in file \"${SM_FILE}\"`)\n  }\n\n  if (!Array.isArray(libraries) || !libraries.length) {\n    return console.error('[next-slicezone] expects \"libraries\" option to be a non-empty array')\n  }\n\n  const librariesInfo = await Promise.all(libraries.map(async lib => await handleLibraryPath(lib)))\n  \n  const declaration = createDeclaration(librariesInfo.filter(e => e))\n\n  const body = createBody()\n\n  const file = \n  `${declaration}\n${body}\n  `\n  return fs.writeFileSync(path.join(process.cwd(), 'sm-resolver.js'), file);\n}"]},"metadata":{},"sourceType":"module"}